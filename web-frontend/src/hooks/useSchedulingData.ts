// React hook for scheduling data management with localStorage
'use client';

import { useState, useEffect } from 'react';
import { Item, Group, DateRange, ShiftTypeRequirementsPreference, ShiftRequestPreference, ShiftTypeSuccessionsPreference, ShiftCountPreference, DataType } from '@/types/scheduling';
import { ItemGroupEditorPageData } from '@/components/ItemGroupEditorPage';
import { AUTO_GENERATED_ITEMS, AUTO_GENERATED_GROUPS, isReservedKeyword, filterAutoGenerated } from '@/utils/keywords';
import { ERROR_SHOULD_NOT_HAPPEN } from '@/constants/errors';

export interface SchedulingState {
  dateRange: DateRange;
  dates: { items: Item[]; groups: Group[] };
  people: { items: Item[]; groups: Group[] };
  shiftTypes: { items: Item[]; groups: Group[] };
  shiftTypeRequirements: ShiftTypeRequirementsPreference[];
  shiftRequestPreferences: ShiftRequestPreference[];
  shiftTypeSuccessions: ShiftTypeSuccessionsPreference[];
  shiftCounts: ShiftCountPreference[];
}

interface HistoryState {
  state: SchedulingState;
  history: SchedulingState[];
  currentHistoryIndex: number;
}

const STORAGE_KEY = 'nurse-scheduling-data';
const MAX_HISTORY_SIZE = 50;

// Constants for infinity value handling in localStorage
// JSON.stringify converts Infinity to null and JSON.parse doesn't handle infinity properly
// These placeholders allow us to safely store and retrieve infinity values
const INFINITY_PLACEHOLDER = '__INFINITY__';
const NEGATIVE_INFINITY_PLACEHOLDER = '__NEGATIVE_INFINITY__';

function generateAutoGeneratedItems(dataType: DataType): Item[] {
  return AUTO_GENERATED_ITEMS[dataType].map(autoItem => ({
    id: autoItem.id,
    description: autoItem.description,
    isAutoGenerated: true
  }));
}

function generateAutoGeneratedGroups(dataType: DataType, items: Item[], dateRange?: DateRange): Group[] {
  return AUTO_GENERATED_GROUPS[dataType].map(autoGroup => ({
    id: autoGroup.id,
    members: autoGroup.generateMembers(filterAutoGenerated(items), dateRange),
    description: autoGroup.description,
    isAutoGenerated: true
  }));
}

function filterAutoGeneratedState(state: SchedulingState): SchedulingState {
  return {
    ...state,
    dates: {
      ...state.dates,
      groups: filterAutoGenerated(state.dates.groups) as Group[]
    },
    people: {
      ...state.people,
      items: filterAutoGenerated(state.people.items) as Item[],
      groups: filterAutoGenerated(state.people.groups) as Group[]
    },
    shiftTypes: {
      ...state.shiftTypes,
      items: filterAutoGenerated(state.shiftTypes.items) as Item[],
      groups: filterAutoGenerated(state.shiftTypes.groups) as Group[]
    }
  };
}

function addAutoGeneratedGroupsToState(state: SchedulingState): SchedulingState {
  const filteredState = filterAutoGeneratedState(state);
  return {
    ...state,
    dates: {
      ...state.dates,
      items: [...filteredState.dates.items, ...generateAutoGeneratedItems(DataType.DATES)],
      groups: [...filteredState.dates.groups, ...generateAutoGeneratedGroups(DataType.DATES, state.dates.items, state.dateRange)]
    },
    people: {
      ...state.people,
      items: [...filteredState.people.items, ...generateAutoGeneratedItems(DataType.PEOPLE)],
      groups: [...filteredState.people.groups, ...generateAutoGeneratedGroups(DataType.PEOPLE, state.people.items)]
    },
    shiftTypes: {
      ...state.shiftTypes,
      items: [...filteredState.shiftTypes.items, ...generateAutoGeneratedItems(DataType.SHIFT_TYPES)],
      groups: [...filteredState.shiftTypes.groups, ...generateAutoGeneratedGroups(DataType.SHIFT_TYPES, state.shiftTypes.items)]
    }
  };
}

// Helper function to convert infinity/-infinity values to safe string representations
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function replaceInfinityValues(obj: any): any {
  if (obj === null || typeof obj !== 'object') {
    if (obj === Infinity) return INFINITY_PLACEHOLDER;
    if (obj === -Infinity) return NEGATIVE_INFINITY_PLACEHOLDER;
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map(replaceInfinityValues);
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const result: any = {};
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      result[key] = replaceInfinityValues(obj[key]);
    }
  }
  return result;
}

// Helper function to restore infinity/-infinity values from safe string representations
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function restoreInfinityValues(obj: any): any {
  if (obj === null || typeof obj !== 'object') {
    if (obj === INFINITY_PLACEHOLDER) return Infinity;
    if (obj === NEGATIVE_INFINITY_PLACEHOLDER) return -Infinity;
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map(restoreInfinityValues);
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const result: any = {};
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      result[key] = restoreInfinityValues(obj[key]);
    }
  }
  return result;
}

// Helper function to generate date items from a date range
function generateDateItems(startDate: string, endDate: string): Item[] {
  const dates: Item[] = [];
  const start = new Date(startDate);
  const end = new Date(endDate);

  // Determine ID format based on date range scope
  const sameYear = start.getFullYear() === end.getFullYear();
  const sameMonth = sameYear && start.getMonth() === end.getMonth();

  for (let date = new Date(start); date <= end; date.setDate(date.getDate() + 1)) {
    const dateStr = date.toISOString().split('T')[0];
    const dayName = date.toLocaleDateString('en-US', { weekday: 'long' });
    const formattedDate = date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric'
    });

    // Generate ID based on date range scope
    let id: string;
    if (sameMonth) {
      id = dateStr.slice(-2); // DD
    } else if (sameYear) {
      id = dateStr.slice(5); // MM-DD
    } else {
      id = dateStr; // YYYY-MM-DD
    }

    dates.push({
      id,
      description: `${dayName}, ${formattedDate}`
    });
  }

  return dates;
}

function createDefaultPeople() {
  return {
    items: Array.from({ length: 10 }, (_, index) => ({
      id: `Person ${index + 1}`,
      description: '',
      history: [] // Start with empty history
    })),
    groups: [
      { id: 'Group 1', members: ['Person 1', 'Person 2'], description: '' },
      { id: 'Group 2', members: ['Person 2', 'Person 3', 'Person 4'], description: '' },
      { id: 'Group 3', members: ['Person 3', 'Person 4', 'Person 5', 'Person 6'], description: '' },
      { id: 'Group 4', members: ['Person 4', 'Person 5', 'Person 6', 'Person 7', 'Person 8'], description: '' },
      { id: 'Group 5', members: ['Person 5', 'Person 6', 'Person 7', 'Person 8', 'Person 9', 'Person 10'], description: '' },
    ]
  };
}

function createDefaultShiftTypes() {
  return {
    items: [
      { id: 'D', description: 'Day (All Levels)' },
      { id: 'D+', description: 'Day (Senior Only)' },
      { id: 'E', description: 'Evening (All Levels)' },
      { id: 'E+', description: 'Evening (Senior Only)' },
      { id: 'N', description: 'Night (All Levels)' },
      { id: 'N+', description: 'Night (Senior Only)' },
      { id: 'A', description: 'Admin (All Levels)' },
      { id: 'A+', description: 'Admin (Senior Only)' },
      { id: 'A-', description: 'Admin (Assistant Only)' },
    ],
    groups: [
      { id: 'Day', members: ['D', 'D+'], description: 'All day shift types' },
      { id: 'Evening', members: ['E', 'E+'], description: 'All evening shift types' },
      { id: 'Night', members: ['N', 'N+'], description: 'All night shift types' },
      { id: 'Administrative', members: ['A', 'A+', 'A-'], description: 'All administrative shift types' },
    ]
  };
}

function createDefaultState(): SchedulingState {
  return {
    dateRange: { startDate: undefined, endDate: undefined },
    dates: { items: [], groups: [] },
    people: createDefaultPeople(),
    shiftTypes: createDefaultShiftTypes(),
    shiftTypeRequirements: [],
    shiftRequestPreferences: [],
    shiftTypeSuccessions: [],
    shiftCounts: []
  };
}

function createDefaultHistoryState(): HistoryState {
  const defaultState = addAutoGeneratedGroupsToState(createDefaultState());
  return {
    state: defaultState,
    history: [defaultState],
    currentHistoryIndex: 0
  };
}

function loadStateFromStorage(): HistoryState {
  if (typeof window === 'undefined') return createDefaultHistoryState();

  try {
    const stored = localStorage.getItem(STORAGE_KEY);

    if (!stored) return createDefaultHistoryState();

    const parsedHistoryState = restoreInfinityValues(JSON.parse(stored)) as HistoryState;

    // Recompute date items for current state if date range exists
    const dateItems = (parsedHistoryState.state.dateRange?.startDate && parsedHistoryState.state.dateRange?.endDate)
      ? generateDateItems(parsedHistoryState.state.dateRange.startDate, parsedHistoryState.state.dateRange.endDate)
      : [];

    const currentState = addAutoGeneratedGroupsToState({
      ...parsedHistoryState.state,
      dates: {
        items: dateItems,
        groups: parsedHistoryState.state.dates?.groups || []
      }
    });

    return {
      state: currentState,
      history: parsedHistoryState.history,
      currentHistoryIndex: Math.min(parsedHistoryState.currentHistoryIndex || 0, parsedHistoryState.history.length - 1)
    };
  } catch (error) {
    console.error('Failed to load data from localStorage:', error);
    return createDefaultHistoryState();
  }
}

function saveStateToStorage(historyState: HistoryState): void {
  if (typeof window === 'undefined') return;

  try {
    // Store the complete history state, but exclude auto-generated groups and computed date items
    const historyStateToStore = {
      state: {
        ...filterAutoGeneratedState(historyState.state),
        dates: {
          ...filterAutoGeneratedState(historyState.state).dates,
          items: undefined  // Don't store computed items
        }
      },
      history: historyState.history.map(state => ({
        ...filterAutoGeneratedState(state),
        dates: {
          ...filterAutoGeneratedState(state).dates,
          items: undefined  // Don't store computed items
        }
      })),
      currentHistoryIndex: historyState.currentHistoryIndex
    };

    // Replace infinity values with safe placeholders before JSON.stringify
    const safeHistoryState = replaceInfinityValues(historyStateToStore);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(safeHistoryState));
  } catch (error) {
    console.error('Failed to save data to localStorage:', error);
  }
}

function addToHistory(currentHistoryState: HistoryState, newState: SchedulingState): HistoryState {
  // Remove any future history if we're not at the end
  const trimmedHistory = currentHistoryState.history.slice(0, currentHistoryState.currentHistoryIndex + 1);

  // Add new state
  const newHistory = [...trimmedHistory, newState];

  // Limit history size
  const limitedHistory = newHistory.length > MAX_HISTORY_SIZE
    ? newHistory.slice(-MAX_HISTORY_SIZE)
    : newHistory;

  const newIndex = limitedHistory.length - 1;

  return {
    state: newState,
    history: limitedHistory,
    currentHistoryIndex: newIndex
  };
}

// Main hook for external use
export function useSchedulingData() {
  const [historyState, setHistoryState] = useState<HistoryState>(createDefaultHistoryState);

  // Load from localStorage on mount
  useEffect(() => {
    const storedHistoryState = loadStateFromStorage();
    setHistoryState(storedHistoryState);
  }, []);

  // Global keyboard shortcuts for undo/redo
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      // Check if Ctrl (or Cmd on Mac) is pressed
      const isCtrlOrCmd = event.ctrlKey || event.metaKey;

      if (!isCtrlOrCmd || event.altKey || event.shiftKey) return;

      // Undo: Ctrl+Z
      if (event.key === 'z') {
        event.preventDefault();
        undo();
        return;
      }

      // Redo: Ctrl+Y
      if (event.key === 'y') {
        event.preventDefault();
        redo();
        return;
      }
    };

    // Add event listener to document
    document.addEventListener('keydown', handleKeyDown);

    // Cleanup function to remove event listener
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  });

  // Generic update function that handles both state update and storage
  const updateState = (updater: (prevState: SchedulingState) => SchedulingState) => {
    setHistoryState(prevHistoryState => {
      const newState = addAutoGeneratedGroupsToState(updater(prevHistoryState.state));
      const newHistoryState = addToHistory(prevHistoryState, newState);
      saveStateToStorage(newHistoryState);
      return newHistoryState;
    });
  };

  // Base function to navigate to a specific history index
  const moveHistoryIndex = (delta: number) => {
    setHistoryState(prevHistoryState => {
      const targetIndex = prevHistoryState.currentHistoryIndex + delta;

      // Validate target index bounds
      if (targetIndex < 0 || targetIndex >= prevHistoryState.history.length || targetIndex === prevHistoryState.currentHistoryIndex) {
        return prevHistoryState;
      }

      const targetState = prevHistoryState.history[targetIndex];

      // Recompute date items for the target state
      const dateItems = (targetState.dateRange?.startDate && targetState.dateRange?.endDate)
        ? generateDateItems(targetState.dateRange.startDate, targetState.dateRange.endDate)
        : [];

      const restoredState = addAutoGeneratedGroupsToState({
        ...targetState,
        dates: {
          ...targetState.dates,
          items: dateItems
        }
      });

      const newHistoryState = {
        ...prevHistoryState,
        state: restoredState,
        currentHistoryIndex: targetIndex
      };

      saveStateToStorage(newHistoryState);
      return newHistoryState;
    });
  };

  // Undo function
  const undo = () => {
    moveHistoryIndex(-1);
  };

  // Redo function
  const redo = () => {
    moveHistoryIndex(1);
  };

  const updateDateRange = (dateRange: DateRange) => {
    updateState(prevState => {
      const dateItems = (dateRange.startDate && dateRange.endDate)
        ? generateDateItems(dateRange.startDate, dateRange.endDate)
        : [];

      return {
        ...prevState,
        dateRange,
        dates: {
          ...prevState.dates,
          items: dateItems
        }
      };
    });
  };

  const updatePeopleData = (peopleData: ItemGroupEditorPageData) => {
    updateState(prevState => ({
      ...prevState,
      people: peopleData
    }));
  };

  const updateShiftTypeData = (shiftTypeData: ItemGroupEditorPageData) => {
    updateState(prevState => ({
      ...prevState,
      shiftTypes: shiftTypeData
    }));
  };

  const updateDateData = (dateData: ItemGroupEditorPageData) => {
    updateState(prevState => ({
      ...prevState,
      dates: {
        items: prevState.dates.items, // Keep computed items
        groups: dateData.groups
      }
    }));
  };

  const updateShiftTypeRequirements = (shiftTypeRequirements: ShiftTypeRequirementsPreference[]) => {
    updateState(prevState => ({
      ...prevState,
      shiftTypeRequirements
    }));
  };

  const updateShiftRequestPreferences = (shiftRequestPreferences: ShiftRequestPreference[]) => {
    updateState(prevState => ({
      ...prevState,
      shiftRequestPreferences
    }));
  };

  const updateShiftTypeSuccessions = (shiftTypeSuccessions: ShiftTypeSuccessionsPreference[]) => {
    updateState(prevState => ({
      ...prevState,
      shiftTypeSuccessions
    }));
  };

  const updateShiftCounts = (shiftCounts: ShiftCountPreference[]) => {
    updateState(prevState => ({
      ...prevState,
      shiftCounts
    }));
  };

  // Private helper function to update data based on dataType
  const updateData = (
    dataType: DataType,
    newData: ItemGroupEditorPageData
  ): void => {
    switch (dataType) {
      case DataType.DATES:
        updateDateData(newData);
        break;
      case DataType.PEOPLE:
        updatePeopleData(newData);
        break;
      case DataType.SHIFT_TYPES:
        updateShiftTypeData(newData);
        break;
    }
  };

  // Reset to defaults
  const createNewState = () => {
    const newState = addAutoGeneratedGroupsToState(createDefaultState());
    const newHistoryState = {
      state: newState,
      history: [newState],
      currentHistoryIndex: 0
    };
    setHistoryState(newHistoryState);
    saveStateToStorage(newHistoryState);
  };

  const addItem = (
    dataType: DataType,
    data: ItemGroupEditorPageData,
    id: string,
    groupIds: string[],
    description?: string
  ): void => {
    // Check if the ID is a reserved keyword
    if (isReservedKeyword(dataType, id)) {
      console.error(`Cannot add item with ID "${id}" - it is a reserved keyword. ${ERROR_SHOULD_NOT_HAPPEN}`);
      return;
    }

    // Add the item
    const newItem = dataType === DataType.PEOPLE
      ? { id, description: description || '', history: [] }
      : { id, description: description || '' };
    const newItems = [...data.items, newItem];

    // If groupIds is provided, add the item to those groups
    const updatedGroups = data.groups.map(group => {
      if (!groupIds.includes(group.id)) {
        return group;
      }
      const allMembers = [...group.members, id];
      // Sort members based on updated items order
      const sortedMembers = newItems
        .filter(item => allMembers.includes(item.id))
        .map(item => item.id);
      if (allMembers.length !== sortedMembers.length) {
        console.error(`All members length ${allMembers.length} does not match sorted members length ${sortedMembers.length}. ${ERROR_SHOULD_NOT_HAPPEN}`);
        return group;
      }
      return {
        ...group,
        members: sortedMembers
      };
    });

    const newData = { items: newItems, groups: updatedGroups };

    updateData(dataType, newData);
  };

  const addGroup = (
    dataType: DataType,
    data: ItemGroupEditorPageData,
    id: string,
    memberIds: string[],
    description?: string
  ): void => {
    // Check if the ID is a reserved keyword
    if (isReservedKeyword(dataType, id)) {
      console.error(`Cannot add group with ID "${id}" - it is a reserved keyword. ${ERROR_SHOULD_NOT_HAPPEN}`);
      return;
    }

    // Sort members based on items order
    const sortedMembers = data.items
      .filter(item => memberIds.includes(item.id))
      .map(item => item.id);

    if (memberIds.length !== sortedMembers.length) {
      console.error(`Member IDs length ${memberIds.length} does not match sorted members length ${sortedMembers.length}. ${ERROR_SHOULD_NOT_HAPPEN}`);
      return;
    }

    const newGroup = { id, members: sortedMembers, description: description || '' };
    const newGroups = [...data.groups, newGroup];

    const newData = { ...data, groups: newGroups };

    updateData(dataType, newData);
  };

  const updateShiftTypeRequirementsForIdChange = (
    dataType: DataType,
    oldId: string,
    newId: string
  ) => {
    const fieldMap = {
      [DataType.DATES]: 'date',
      [DataType.PEOPLE]: 'qualified_people',
      [DataType.SHIFT_TYPES]: 'shift_type'
    };

    const fieldName = fieldMap[dataType] as keyof ShiftTypeRequirementsPreference;

    updateState(prevState => ({
      ...prevState,
      shiftTypeRequirements: prevState.shiftTypeRequirements.map(requirement => ({
        ...requirement,
        [fieldName]: (requirement[fieldName] as string[]).map(id => id === oldId ? newId : id)
      }))
    }));
  };

  const updateShiftTypeRequirementsForIdDeletion = (
    dataType: DataType,
    deletedId: string
  ) => {
    const fieldMap = {
      [DataType.DATES]: 'date',
      [DataType.PEOPLE]: 'qualified_people',
      [DataType.SHIFT_TYPES]: 'shift_type'
    };

    const fieldName = fieldMap[dataType] as keyof ShiftTypeRequirementsPreference;

    updateState(prevState => ({
      ...prevState,
      shiftTypeRequirements: prevState.shiftTypeRequirements.map(requirement => ({
        ...requirement,
        [fieldName]: (requirement[fieldName] as string[]).filter(id => id !== deletedId)
      }))
    }));

    // If the `shift_type` field is empty, remove the requirement.
    updateState(prevState => ({
      ...prevState,
      shiftTypeRequirements: prevState.shiftTypeRequirements.filter(requirement => requirement.shift_type.length > 0)
    }));
  };

  const updateShiftRequestPreferencesForIdChange = (
    dataType: DataType,
    oldId: string,
    newId: string
  ) => {
    const fieldMap = {
      [DataType.DATES]: 'date',
      [DataType.PEOPLE]: 'person',
      [DataType.SHIFT_TYPES]: 'shift_type'
    };

    const fieldName = fieldMap[dataType] as keyof ShiftRequestPreference;

    updateState(prevState => ({
      ...prevState,
      shiftRequestPreferences: prevState.shiftRequestPreferences.map(preference => ({
        ...preference,
        [fieldName]: preference[fieldName] === oldId ? newId : preference[fieldName]
      }))
    }));
  };

  const updateShiftRequestPreferencesForIdDeletion = (
    dataType: DataType,
    deletedId: string
  ) => {
    const fieldMap = {
      [DataType.DATES]: 'date',
      [DataType.PEOPLE]: 'person',
      [DataType.SHIFT_TYPES]: 'shift_type'
    };

    const fieldName = fieldMap[dataType] as keyof ShiftRequestPreference;

    updateState(prevState => ({
      ...prevState,
      shiftRequestPreferences: prevState.shiftRequestPreferences.filter(preference => preference[fieldName] !== deletedId)
    }));
  };

  const updateShiftCountsForIdChange = (
    dataType: DataType,
    oldId: string,
    newId: string
  ) => {
    const fieldMap = {
      [DataType.DATES]: 'count_dates',
      [DataType.PEOPLE]: 'person',
      [DataType.SHIFT_TYPES]: 'count_shift_types'
    };

    const fieldName = fieldMap[dataType] as keyof ShiftCountPreference;

    updateState(prevState => ({
      ...prevState,
      shiftCounts: prevState.shiftCounts.map(shiftCount => ({
        ...shiftCount,
        [fieldName]: (shiftCount[fieldName] as string[]).map(id => id === oldId ? newId : id)
      }))
    }));
  };

  const updateShiftCountsForIdDeletion = (
    dataType: DataType,
    deletedId: string
  ) => {
    const fieldMap = {
      [DataType.DATES]: 'count_dates',
      [DataType.PEOPLE]: 'person',
      [DataType.SHIFT_TYPES]: 'count_shift_types'
    };

    const fieldName = fieldMap[dataType] as keyof ShiftCountPreference;

    updateState(prevState => ({
      ...prevState,
      shiftCounts: prevState.shiftCounts.map(shiftCount => ({
        ...shiftCount,
        [fieldName]: (shiftCount[fieldName] as string[]).filter(id => id !== deletedId)
      }))
    }));

    // If the `person` field is empty, remove the shift count.
    updateState(prevState => ({
      ...prevState,
      shiftCounts: prevState.shiftCounts.filter(shiftCount => shiftCount.person.length > 0)
    }));
  };

  const updateItem = (
    dataType: DataType,
    data: ItemGroupEditorPageData,
    oldId: string,
    newId: string,
    groupIds?: string[],
    description?: string
  ): void => {
    // Check if the new ID is a reserved keyword
    if (isReservedKeyword(dataType, newId)) {
      console.error(`Cannot update item to ID "${newId}" - it is a reserved keyword. ${ERROR_SHOULD_NOT_HAPPEN}`);
      return;
    }

    // First update the item's ID and description
    const updatedItems = data.items.map(item =>
      item.id === oldId
        ? { ...item, id: newId, description: description !== undefined ? description : item.description }
        : item
    );

    // Always update group memberships to reflect the new ID
    const updatedGroups = data.groups.map(group => {
      // Get current members excluding the edited item
      const otherMembers = group.members.filter(id => id !== oldId);

      // Add the item if they should be in this group
      const allMembers = groupIds
        ? (groupIds.includes(group.id) ? [...otherMembers, newId] : otherMembers)
        : (group.members.includes(oldId) ? [...otherMembers, newId] : otherMembers);

      // Sort members based on updated items order
      const sortedMembers = updatedItems
        .filter(item => allMembers.includes(item.id))
        .map(item => item.id);

      if (allMembers.length !== sortedMembers.length) {
        console.error(`All members length ${allMembers.length} does not match sorted members length ${sortedMembers.length}. ${ERROR_SHOULD_NOT_HAPPEN}`);
        return group;
      }

      return {
        ...group,
        members: sortedMembers
      };
    });

    const newData = { items: updatedItems, groups: updatedGroups };

    updateData(dataType, newData);
    updateShiftTypeRequirementsForIdChange(dataType, oldId, newId);
    updateShiftRequestPreferencesForIdChange(dataType, oldId, newId);
    updateShiftCountsForIdChange(dataType, oldId, newId);
  };

  const updateGroup = (
    dataType: DataType,
    data: ItemGroupEditorPageData,
    oldId: string,
    newId: string,
    members?: string[],
    description?: string
  ): void => {
    // Check if the new ID is a reserved keyword
    if (isReservedKeyword(dataType, newId)) {
      console.error(`Cannot update group to ID "${newId}" - it is a reserved keyword. ${ERROR_SHOULD_NOT_HAPPEN}`);
      return;
    }

    const group = data.groups.find(g => g.id === oldId);
    if (!group) {
      console.error(`Group with ID ${oldId} not found. ${ERROR_SHOULD_NOT_HAPPEN}`);
      return;
    }

    // Sort members based on items order
    const sortedMembers = members
      ? data.items
          .filter(item => members.includes(item.id))
          .map(item => item.id)
      : group.members;

    if (members && members.length !== sortedMembers.length) {
      console.error(`Members length ${members.length} does not match sorted members length ${sortedMembers.length}. ${ERROR_SHOULD_NOT_HAPPEN}`);
      return;
    }

    const newGroups = data.groups.map(g =>
      g.id === oldId
        ? { ...g, id: newId, members: sortedMembers, description: description !== undefined ? description : g.description }
        : g
    );

    const newData = { ...data, groups: newGroups };

    updateData(dataType, newData);
    updateShiftTypeRequirementsForIdChange(dataType, oldId, newId);
    updateShiftRequestPreferencesForIdChange(dataType, oldId, newId);
    updateShiftCountsForIdChange(dataType, oldId, newId);
  };

  const deleteItem = (
    dataType: DataType,
    data: ItemGroupEditorPageData,
    id: string
  ): void => {
    if (isReservedKeyword(dataType, id)) {
      console.error(`Cannot delete item with ID "${id}" - it is a reserved keyword. ${ERROR_SHOULD_NOT_HAPPEN}`);
      return;
    }

    const newItems = data.items.filter(item => item.id !== id);
    const newGroups = data.groups.map(group => ({
      ...group,
      members: group.members.filter(memberId => memberId !== id)
    }));

    const newData = { items: newItems, groups: newGroups };

    updateData(dataType, newData);
    updateShiftTypeRequirementsForIdDeletion(dataType, id);
    updateShiftRequestPreferencesForIdDeletion(dataType, id);
    updateShiftCountsForIdDeletion(dataType, id);
  };

  const deleteGroup = (
    dataType: DataType,
    data: ItemGroupEditorPageData,
    id: string
  ): void => {
    if (isReservedKeyword(dataType, id)) {
      console.error(`Cannot delete group with ID "${id}" - it is a reserved keyword. ${ERROR_SHOULD_NOT_HAPPEN}`);
      return;
    }

    const newGroups = data.groups.filter(g => g.id !== id);
    const newData = { ...data, groups: newGroups };

    updateData(dataType, newData);
    updateShiftTypeRequirementsForIdDeletion(dataType, id);
    updateShiftRequestPreferencesForIdDeletion(dataType, id);
    updateShiftCountsForIdDeletion(dataType, id);
  };

  const removeItemFromGroup = (
    dataType: DataType,
    data: ItemGroupEditorPageData,
    itemId: string,
    groupId: string
  ): void => {
    if (isReservedKeyword(dataType, groupId)) {
      console.error(`Cannot remove item from group with ID "${groupId}" - it is a reserved keyword. ${ERROR_SHOULD_NOT_HAPPEN}`);
      return;
    }

    const newGroups = data.groups.map(group =>
      group.id === groupId
        ? { ...group, members: group.members.filter(id => id !== itemId) }
        : group
    );

    const newData = { ...data, groups: newGroups };

    updateData(dataType, newData);
  };

  const reorderItems = (
    dataType: DataType,
    data: ItemGroupEditorPageData,
    reorderedItems: Item[]
  ): void => {
    // Sort group members based on items order
    const updatedGroups = data.groups.map(group => ({
      ...group,
      members: reorderedItems
        .filter(item => group.members.includes(item.id))
        .map(item => item.id)
    }));

    const newData = { items: reorderedItems, groups: updatedGroups };

    updateData(dataType, newData);
  };

  const reorderGroups = (
    dataType: DataType,
    data: ItemGroupEditorPageData,
    newGroups: Group[]
  ): void => {
    const newData = { ...data, groups: newGroups };

    updateData(dataType, newData);
  };

  const addPersonHistory = (personId: string, shiftTypeId: string) => {
    updateState(prevState => {
      const updatedPeople = {
        ...prevState.people,
        items: prevState.people.items.map(person => {
          if (person.id === personId) {
            const newHistory = [shiftTypeId, ...person.history!];
            return { ...person, history: newHistory };
          }
          return person;
        })
      };
      return { ...prevState, people: updatedPeople };
    });
  };

  const updatePersonHistory = (personId: string, position: number, shiftTypeId?: string) => {
    updateState(prevState => {
      const updatedPeople = {
        ...prevState.people,
        items: prevState.people.items.map(person => {
          if (person.id === personId) {
            if (shiftTypeId !== undefined) {
              // Update the specific position
              const newHistory = [...person.history!];
              if (position >= newHistory.length) {
                console.error(`Position ${position} is out of bounds for person ${personId}. ${ERROR_SHOULD_NOT_HAPPEN}`);
                return person;
              }
              newHistory[position] = shiftTypeId;
              return { ...person, history: newHistory };
            } else {
              // Clear all history entries before the specified position
              const newHistory = person.history!.slice(position + 1);
              return { ...person, history: newHistory };
            }
          }
          return person;
        })
      };
      return { ...prevState, people: updatedPeople };
    });
  };

  return {
    dateRange: historyState.state.dateRange,
    updateDateRange,
    dateData: historyState.state.dates,
    peopleData: historyState.state.people,
    shiftTypeData: historyState.state.shiftTypes,
    shiftTypeRequirements: historyState.state.shiftTypeRequirements,
    updateShiftTypeRequirements,
    shiftRequestPreferences: historyState.state.shiftRequestPreferences,
    updateShiftRequestPreferences,
    shiftTypeSuccessions: historyState.state.shiftTypeSuccessions,
    updateShiftTypeSuccessions,
    shiftCounts: historyState.state.shiftCounts,
    updateShiftCounts,
    addPersonHistory,
    updatePersonHistory,
    createNewState,
    undo,
    redo,
    // Helper functions
    addItem,
    addGroup,
    updateItem,
    updateGroup,
    deleteItem,
    deleteGroup,
    removeItemFromGroup,
    reorderItems,
    reorderGroups,
  };
}
