// React hook for scheduling data management with localStorage
'use client';

import { useState, useEffect } from 'react';
import { Item, Group, DateRange, ShiftTypeRequirementsPreference, ShiftRequestPreference, ShiftTypeSuccessionsPreference, ShiftCountPreference, DataType, Preference, AT_MOST_ONE_SHIFT_PER_DAY, SHIFT_TYPE_REQUIREMENT, SHIFT_REQUEST, SHIFT_TYPE_SUCCESSIONS, SHIFT_COUNT } from '@/types/scheduling';
import { ItemGroupEditorPageData } from '@/components/ItemGroupEditorPage';
import { AUTO_GENERATED_ITEMS, AUTO_GENERATED_GROUPS, isReservedKeyword, filterAutoGenerated, API_VERSION } from '@/utils/keywords';
import { ERROR_SHOULD_NOT_HAPPEN } from '@/constants/errors';

export interface SchedulingState {
  apiVersion: string | number;
  description: string;
  dates: { range: DateRange, items: Item[]; groups: Group[] };
  people: { items: Item[]; groups: Group[]; history: string[] };
  shiftTypes: { items: Item[]; groups: Group[] };
  preferences: Preference[];
}

interface HistoryState {
  state: SchedulingState;
  history: SchedulingState[];
  currentHistoryIndex: number;
}

const STORAGE_KEY = 'nurse-scheduling-data';
const MAX_HISTORY_SIZE = 50;

// Constants for infinity value handling in localStorage
// JSON.stringify converts Infinity to null and JSON.parse doesn't handle infinity properly
// These placeholders allow us to safely store and retrieve infinity values
const INFINITY_PLACEHOLDER = '__INFINITY__';
const NEGATIVE_INFINITY_PLACEHOLDER = '__NEGATIVE_INFINITY__';

// Helper function to generate date items from a date range
function _generateDateItems(startDate: Date, endDate: Date): Item[] {
  const dates: Item[] = [];

  // Determine ID format based on date range scope
  const sameYear = startDate.getFullYear() === endDate.getFullYear();
  const sameMonth = sameYear && startDate.getMonth() === endDate.getMonth();

  for (let date = new Date(startDate); date <= endDate; date.setDate(date.getDate() + 1)) {
    const dateStr = date.toISOString().split('T')[0];
    const dayName = date.toLocaleDateString('en-US', { weekday: 'long' });
    const formattedDate = date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric'
    });

    // Generate ID based on date range scope
    let id: string;
    if (sameMonth) {
      id = dateStr.slice(-2); // DD
    } else if (sameYear) {
      id = dateStr.slice(5); // MM-DD
    } else {
      id = dateStr; // YYYY-MM-DD
    }

    dates.push({
      id,
      description: `${dayName}, ${formattedDate}`
    });
  }

  return dates;
}

function _generateAutoGeneratedItems(dataType: DataType, dateRange?: DateRange): Item[] {
  const autoGeneratedItems: Item[] = [];

  if (dataType === DataType.DATES && dateRange?.startDate && dateRange?.endDate) {
    autoGeneratedItems.push(
      ..._generateDateItems(dateRange.startDate, dateRange.endDate).map(date => ({
        id: date.id,
        description: date.description,
        isAutoGenerated: true
      }))
    );
  }
  autoGeneratedItems.push(
    ...AUTO_GENERATED_ITEMS[dataType].map(autoItem => ({
      id: autoItem.id,
      description: autoItem.description,
      isAutoGenerated: true
    }))
  );

  return autoGeneratedItems;
}

function _generateAutoGeneratedGroups(dataType: DataType, items: Item[], dateRange?: DateRange): Group[] {
  let filteredItems = filterAutoGenerated(items);
  if (dataType === DataType.DATES && dateRange?.startDate && dateRange?.endDate) {
    filteredItems = _generateDateItems(dateRange.startDate, dateRange.endDate);
  }
  return AUTO_GENERATED_GROUPS[dataType].map(autoGroup => ({
    id: autoGroup.id,
    members: autoGroup.generateMembers(filteredItems, dateRange),
    description: autoGroup.description,
    isAutoGenerated: true
  }));
}

function filterAutoGeneratedState(state: SchedulingState): SchedulingState {
  return {
    ...state,
    dates: {
      ...state.dates,
      items: filterAutoGenerated(state.dates.items) as Item[],
      groups: filterAutoGenerated(state.dates.groups) as Group[]
    },
    people: {
      ...state.people,
      items: filterAutoGenerated(state.people.items) as Item[],
      groups: filterAutoGenerated(state.people.groups) as Group[]
    },
    shiftTypes: {
      ...state.shiftTypes,
      items: filterAutoGenerated(state.shiftTypes.items) as Item[],
      groups: filterAutoGenerated(state.shiftTypes.groups) as Group[]
    }
  };
}

function addAutoGeneratedToState(state: SchedulingState): SchedulingState {
  const filteredState = filterAutoGeneratedState(state);
  return {
    ...state,
    dates: {
      ...state.dates,
      items: [...filteredState.dates.items, ..._generateAutoGeneratedItems(DataType.DATES, state.dates.range)],
      groups: [...filteredState.dates.groups, ..._generateAutoGeneratedGroups(DataType.DATES, state.dates.items, state.dates.range)]
    },
    people: {
      ...state.people,
      items: [...filteredState.people.items, ..._generateAutoGeneratedItems(DataType.PEOPLE)],
      groups: [...filteredState.people.groups, ..._generateAutoGeneratedGroups(DataType.PEOPLE, state.people.items)]
    },
    shiftTypes: {
      ...state.shiftTypes,
      items: [...filteredState.shiftTypes.items, ..._generateAutoGeneratedItems(DataType.SHIFT_TYPES)],
      groups: [...filteredState.shiftTypes.groups, ..._generateAutoGeneratedGroups(DataType.SHIFT_TYPES, state.shiftTypes.items)]
    }
  };
}

// Helper function to convert infinity/-infinity values to safe string representations
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function replaceInfinityValues(obj: any): any {
  if (obj === null || typeof obj !== 'object') {
    if (obj === Infinity) return INFINITY_PLACEHOLDER;
    if (obj === -Infinity) return NEGATIVE_INFINITY_PLACEHOLDER;
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map(replaceInfinityValues);
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const result: any = {};
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      result[key] = replaceInfinityValues(obj[key]);
    }
  }
  return result;
}

// Helper function to restore infinity/-infinity values from safe string representations
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function restoreInfinityValues(obj: any): any {
  if (obj === null || typeof obj !== 'object') {
    if (obj === INFINITY_PLACEHOLDER) return Infinity;
    if (obj === NEGATIVE_INFINITY_PLACEHOLDER) return -Infinity;
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map(restoreInfinityValues);
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const result: any = {};
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      result[key] = restoreInfinityValues(obj[key]);
    }
  }
  return result;
}

function createDefaultPeople() {
  return {
    items: Array.from({ length: 10 }, (_, index) => ({
      id: `Person ${index + 1}`,
      description: '',
      history: [] // Start with empty history
    })),
    groups: [
      { id: 'Group 1', members: ['Person 1', 'Person 2'], description: '' },
      { id: 'Group 2', members: ['Person 2', 'Person 3', 'Person 4'], description: '' },
      { id: 'Group 3', members: ['Person 3', 'Person 4', 'Person 5', 'Person 6'], description: '' },
      { id: 'Group 4', members: ['Person 4', 'Person 5', 'Person 6', 'Person 7', 'Person 8'], description: '' },
      { id: 'Group 5', members: ['Person 5', 'Person 6', 'Person 7', 'Person 8', 'Person 9', 'Person 10'], description: '' },
    ],
    history: []
  };
}

function createDefaultShiftTypes() {
  return {
    items: [
      { id: 'D', description: 'Day (All Levels)' },
      { id: 'D+', description: 'Day (Senior Only)' },
      { id: 'E', description: 'Evening (All Levels)' },
      { id: 'E+', description: 'Evening (Senior Only)' },
      { id: 'N', description: 'Night (All Levels)' },
      { id: 'N+', description: 'Night (Senior Only)' },
      { id: 'A', description: 'Admin (All Levels)' },
      { id: 'A+', description: 'Admin (Senior Only)' },
      { id: 'A-', description: 'Admin (Assistant Only)' },
    ],
    groups: [
      { id: 'Day', members: ['D', 'D+'], description: 'All day shift types' },
      { id: 'Evening', members: ['E', 'E+'], description: 'All evening shift types' },
      { id: 'Night', members: ['N', 'N+'], description: 'All night shift types' },
      { id: 'Administrative', members: ['A', 'A+', 'A-'], description: 'All administrative shift types' },
    ]
  };
}

function createDefaultState(): SchedulingState {
  return {
    apiVersion: API_VERSION,
    description: '',
    dates: { range: { startDate: undefined, endDate: undefined }, items: [], groups: [] },
    people: createDefaultPeople(),
    shiftTypes: createDefaultShiftTypes(),
    preferences: [
      {
        type: AT_MOST_ONE_SHIFT_PER_DAY
      }
    ]
  };
}

function createDefaultHistoryState(): HistoryState {
  const defaultState = addAutoGeneratedToState(createDefaultState());
  return {
    state: defaultState,
    history: [defaultState],
    currentHistoryIndex: 0
  };
}

function loadStateFromStorage(): HistoryState {
  if (typeof window === 'undefined') return createDefaultHistoryState();

  try {
    const stored = localStorage.getItem(STORAGE_KEY);

    if (!stored) return createDefaultHistoryState();

    const parsedHistoryState = restoreInfinityValues(JSON.parse(stored)) as HistoryState;

    for (const state of [...parsedHistoryState.history, parsedHistoryState.state]) {
      state.dates.range.startDate = state.dates.range.startDate ? new Date(state.dates.range.startDate) : undefined;
      state.dates.range.endDate = state.dates.range.endDate ? new Date(state.dates.range.endDate) : undefined;
    }

    const currentState = addAutoGeneratedToState(parsedHistoryState.state);

    return {
      state: currentState,
      history: parsedHistoryState.history,
      currentHistoryIndex: Math.min(parsedHistoryState.currentHistoryIndex || 0, parsedHistoryState.history.length - 1)
    };
  } catch (error) {
    console.error('Failed to load data from localStorage:', error);
    return createDefaultHistoryState();
  }
}

function saveStateToStorage(historyState: HistoryState): void {
  if (typeof window === 'undefined') return;

  try {
    // Store the complete history state, but exclude auto-generated groups and computed date items
    const historyStateToStore = {
      state: {
        ...filterAutoGeneratedState(historyState.state),
        dates: {
          ...filterAutoGeneratedState(historyState.state).dates,
          range: {
            startDate: historyState.state.dates.range.startDate?.toISOString().split('T')[0],
            endDate: historyState.state.dates.range.endDate?.toISOString().split('T')[0]
          },
          items: undefined  // Don't store computed items
        }
      },
      history: historyState.history.map(state => ({
        ...filterAutoGeneratedState(state),
        dates: {
          ...filterAutoGeneratedState(state).dates,
          range: {
            startDate: state.dates.range.startDate?.toISOString().split('T')[0],
            endDate: state.dates.range.endDate?.toISOString().split('T')[0]
          },
          items: undefined  // Don't store computed items
        }
      })),
      currentHistoryIndex: historyState.currentHistoryIndex
    };

    // Replace infinity values with safe placeholders before JSON.stringify
    const safeHistoryState = replaceInfinityValues(historyStateToStore);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(safeHistoryState));
  } catch (error) {
    console.error('Failed to save data to localStorage:', error);
  }
}

function addToHistory(currentHistoryState: HistoryState, newState: SchedulingState): HistoryState {
  // Remove any future history if we're not at the end
  const trimmedHistory = currentHistoryState.history.slice(0, currentHistoryState.currentHistoryIndex + 1);

  // Add new state
  const newHistory = [...trimmedHistory, newState];

  // Limit history size
  const limitedHistory = newHistory.length > MAX_HISTORY_SIZE
    ? newHistory.slice(-MAX_HISTORY_SIZE)
    : newHistory;

  const newIndex = limitedHistory.length - 1;

  return {
    state: newState,
    history: limitedHistory,
    currentHistoryIndex: newIndex
  };
}

// Main hook for external use
export function useSchedulingData() {
  const [historyState, setHistoryState] = useState<HistoryState>(createDefaultHistoryState);

  // Load from localStorage on mount
  useEffect(() => {
    const storedHistoryState = loadStateFromStorage();
    setHistoryState(storedHistoryState);
  }, []);

  // Global keyboard shortcuts for undo/redo
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      // Check if Ctrl (or Cmd on Mac) is pressed
      const isCtrlOrCmd = event.ctrlKey || event.metaKey;

      if (!isCtrlOrCmd || event.altKey || event.shiftKey) return;

      // Undo: Ctrl+Z
      if (event.key === 'z') {
        event.preventDefault();
        undo();
        return;
      }

      // Redo: Ctrl+Y
      if (event.key === 'y') {
        event.preventDefault();
        redo();
        return;
      }
    };

    // Add event listener to document
    document.addEventListener('keydown', handleKeyDown);

    // Cleanup function to remove event listener
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  });

  // Generic update function that handles both state update and storage
  const updateState = (updater: (prevState: SchedulingState) => SchedulingState) => {
    setHistoryState(prevHistoryState => {
      const newState = addAutoGeneratedToState(updater(prevHistoryState.state));
      const newHistoryState = addToHistory(prevHistoryState, newState);
      saveStateToStorage(newHistoryState);
      return newHistoryState;
    });
  };

  // Base function to navigate to a specific history index
  const moveHistoryIndex = (delta: number) => {
    setHistoryState(prevHistoryState => {
      const targetIndex = prevHistoryState.currentHistoryIndex + delta;

      // Validate target index bounds
      if (targetIndex < 0 || targetIndex >= prevHistoryState.history.length || targetIndex === prevHistoryState.currentHistoryIndex) {
        return prevHistoryState;
      }

      const targetState = prevHistoryState.history[targetIndex];

      const restoredState = addAutoGeneratedToState(targetState);

      const newHistoryState = {
        ...prevHistoryState,
        state: restoredState,
        currentHistoryIndex: targetIndex
      };

      saveStateToStorage(newHistoryState);
      return newHistoryState;
    });
  };

  // Undo function
  const undo = () => {
    moveHistoryIndex(-1);
  };

  // Redo function
  const redo = () => {
    moveHistoryIndex(1);
  };

  const updateDateRange = (dateRange: DateRange) => {
    updateState(prevState => {
      return {
        ...prevState,
        dates: {
          ...prevState.dates,
          range: dateRange,
        }
      };
    });
  };

  const updatePeopleData = (peopleData: ItemGroupEditorPageData) => {
    updateState(prevState => ({
      ...prevState,
      people: peopleData
    }));
  };

  const updateShiftTypeData = (shiftTypeData: ItemGroupEditorPageData) => {
    updateState(prevState => ({
      ...prevState,
      shiftTypes: shiftTypeData
    }));
  };

  const updateDateData = (dateData: ItemGroupEditorPageData) => {
    updateState(prevState => ({
      ...prevState,
      dates: {
        ...prevState.dates,
        items: prevState.dates.items, // Keep computed items
        groups: dateData.groups
      }
    }));
  };



  // Private helper function to update data based on dataType
  const updateData = (
    dataType: DataType,
    newData: ItemGroupEditorPageData
  ): void => {
    switch (dataType) {
      case DataType.DATES:
        updateDateData(newData);
        break;
      case DataType.PEOPLE:
        updatePeopleData(newData);
        break;
      case DataType.SHIFT_TYPES:
        updateShiftTypeData(newData);
        break;
    }
  };

  // Reset to defaults
  const createNewState = () => {
    const newState = addAutoGeneratedToState(createDefaultState());
    const newHistoryState = {
      state: newState,
      history: [newState],
      currentHistoryIndex: 0
    };
    setHistoryState(newHistoryState);
    saveStateToStorage(newHistoryState);
  };

  const addItem = (
    dataType: DataType,
    data: ItemGroupEditorPageData,
    id: string,
    groupIds: string[],
    description?: string
  ): void => {
    // Check if the ID is a reserved keyword
    if (isReservedKeyword(dataType, id)) {
      console.error(`Cannot add item with ID "${id}" - it is a reserved keyword. ${ERROR_SHOULD_NOT_HAPPEN}`);
      return;
    }

    // Add the item
    const newItem = dataType === DataType.PEOPLE
      ? { id, description: description || '', history: [] }
      : { id, description: description || '' };
    const newItems = [...data.items, newItem];

    // If groupIds is provided, add the item to those groups
    const updatedGroups = data.groups.map(group => {
      if (!groupIds.includes(group.id)) {
        return group;
      }
      const allMembers = [...group.members, id];
      // Sort members based on updated items order
      const sortedMembers = newItems
        .filter(item => allMembers.includes(item.id))
        .map(item => item.id);
      if (allMembers.length !== sortedMembers.length) {
        console.error(`All members length ${allMembers.length} does not match sorted members length ${sortedMembers.length}. ${ERROR_SHOULD_NOT_HAPPEN}`);
        return group;
      }
      return {
        ...group,
        members: sortedMembers
      };
    });

    const newData = { items: newItems, groups: updatedGroups };

    updateData(dataType, newData);
  };

  const addGroup = (
    dataType: DataType,
    data: ItemGroupEditorPageData,
    id: string,
    memberIds: string[],
    description?: string
  ): void => {
    // Check if the ID is a reserved keyword
    if (isReservedKeyword(dataType, id)) {
      console.error(`Cannot add group with ID "${id}" - it is a reserved keyword. ${ERROR_SHOULD_NOT_HAPPEN}`);
      return;
    }

    // Sort members based on items order
    const sortedMembers = data.items
      .filter(item => memberIds.includes(item.id))
      .map(item => item.id);

    if (memberIds.length !== sortedMembers.length) {
      console.error(`Member IDs length ${memberIds.length} does not match sorted members length ${sortedMembers.length}. ${ERROR_SHOULD_NOT_HAPPEN}`);
      return;
    }

    const newGroup = { id, members: sortedMembers, description: description || '' };
    const newGroups = [...data.groups, newGroup];

    const newData = { ...data, groups: newGroups };

    updateData(dataType, newData);
  };

  const updatePeopleHistoryForIdChange = (dataType: DataType, oldId: string, newId: string) => {
    if (dataType !== DataType.SHIFT_TYPES) return;
    updateState(prevState => ({
      ...prevState,
      people: {
        ...prevState.people,
        items: prevState.people.items.map(person => ({
          ...person,
          history: person.history?.map(h => h === oldId ? newId : h) || []
        }))
      }
    }));
  };

  // Unified function to update preferences when an ID changes
  const updatePreferencesForIdChange = (
    dataType: DataType,
    oldId: string,
    newId: string
  ) => {
    const shiftTypeReqFieldMap = {
      [DataType.DATES]: 'date',
      [DataType.PEOPLE]: 'qualifiedPeople',
      [DataType.SHIFT_TYPES]: 'shiftType'
    };

    const shiftRequestFieldMap = {
      [DataType.DATES]: 'date',
      [DataType.PEOPLE]: 'person',
      [DataType.SHIFT_TYPES]: 'shiftType'
    };

    const shiftTypeSuccessionsFieldMap = {
      [DataType.DATES]: undefined,
      [DataType.PEOPLE]: 'person',
      [DataType.SHIFT_TYPES]: 'pattern'
    };

    const shiftCountFieldMap = {
      [DataType.DATES]: 'countDates',
      [DataType.PEOPLE]: 'person',
      [DataType.SHIFT_TYPES]: 'countShiftTypes'
    };

    updateState(prevState => ({
      ...prevState,
      preferences: prevState.preferences.map(pref => {
        if (pref.type === SHIFT_TYPE_REQUIREMENT) {
          const fieldName = shiftTypeReqFieldMap[dataType] as keyof ShiftTypeRequirementsPreference;
          return {
            ...pref,
            [fieldName]: ((pref as ShiftTypeRequirementsPreference)[fieldName] as string[]).map(id => id === oldId ? newId : id)
          };
        } else if (pref.type === SHIFT_REQUEST) {
          const fieldName = shiftRequestFieldMap[dataType] as keyof ShiftRequestPreference;
          return {
            ...pref,
            [fieldName]: ((pref as ShiftRequestPreference)[fieldName] as string[]).map(id => id === oldId ? newId : id)
          };
        } else if (pref.type === SHIFT_TYPE_SUCCESSIONS) {
          if (shiftTypeSuccessionsFieldMap[dataType] === undefined) {
            return pref;
          }
          const fieldName = shiftTypeSuccessionsFieldMap[dataType] as keyof ShiftTypeSuccessionsPreference;
          return {
            ...pref,
            [fieldName]: ((pref as ShiftTypeSuccessionsPreference)[fieldName] as string[]).map(id => id === oldId ? newId : id)
          };
        } else if (pref.type === SHIFT_COUNT) {
          const fieldName = shiftCountFieldMap[dataType] as keyof ShiftCountPreference;
          return {
            ...pref,
            [fieldName]: ((pref as ShiftCountPreference)[fieldName] as string[]).map(id => id === oldId ? newId : id)
          };
        }
        return pref;
      })
    }));
  };

  // Unified function to update preferences when an ID is deleted
  const updatePreferencesForIdDeletion = (
    dataType: DataType,
    deletedId: string
  ) => {
    const shiftTypeReqFieldMap = {
      [DataType.DATES]: 'date',
      [DataType.PEOPLE]: 'qualifiedPeople',
      [DataType.SHIFT_TYPES]: 'shiftType'
    };

    const shiftRequestFieldMap = {
      [DataType.DATES]: 'date',
      [DataType.PEOPLE]: 'person',
      [DataType.SHIFT_TYPES]: 'shiftType'
    };

    const shiftTypeSuccessionsFieldMap = {
      [DataType.DATES]: undefined,
      [DataType.PEOPLE]: 'person',
      [DataType.SHIFT_TYPES]: 'pattern'
    };

    const shiftCountFieldMap = {
      [DataType.DATES]: 'countDates',
      [DataType.PEOPLE]: 'person',
      [DataType.SHIFT_TYPES]: 'countShiftTypes'
    };

    // First, filter out the deleted ID from array fields and remove matching single-value preferences
    updateState(prevState => ({
      ...prevState,
      preferences: prevState.preferences
        .map(pref => {
          if (pref.type === SHIFT_TYPE_REQUIREMENT) {
            const fieldName = shiftTypeReqFieldMap[dataType] as keyof ShiftTypeRequirementsPreference;
            return {
              ...pref,
              [fieldName]: ((pref as ShiftTypeRequirementsPreference)[fieldName] as string[]).filter(id => id !== deletedId)
            };
          } else if (pref.type === SHIFT_REQUEST) {
            const fieldName = shiftRequestFieldMap[dataType] as keyof ShiftRequestPreference;
            return {
              ...pref,
              [fieldName]: ((pref as ShiftRequestPreference)[fieldName] as string[]).filter(id => id !== deletedId)
            };
          } else if (pref.type === SHIFT_TYPE_SUCCESSIONS) {
            if (shiftTypeSuccessionsFieldMap[dataType] === undefined) {
              return pref;
            }
            const fieldName = shiftTypeSuccessionsFieldMap[dataType] as keyof ShiftTypeSuccessionsPreference;
            return {
              ...pref,
              [fieldName]: ((pref as ShiftTypeSuccessionsPreference)[fieldName] as string[]).filter(id => id !== deletedId)
            };
          } else if (pref.type === SHIFT_COUNT) {
            const fieldName = shiftCountFieldMap[dataType] as keyof ShiftCountPreference;
            return {
              ...pref,
              [fieldName]: ((pref as ShiftCountPreference)[fieldName] as string[]).filter(id => id !== deletedId)
            };
          }
          return pref;
        })
    }));

    // Second, remove preferences with empty required fields
    updateState(prevState => ({
      ...prevState,
      preferences: prevState.preferences.filter(pref => {
        if (pref.type === SHIFT_TYPE_REQUIREMENT) {
          return (pref as ShiftTypeRequirementsPreference).shiftType.length > 0;
        } else if (pref.type === SHIFT_REQUEST) {
          return (pref as ShiftRequestPreference).person.length > 0 &&
            (pref as ShiftRequestPreference).date.length > 0 &&
            (pref as ShiftRequestPreference).shiftType.length > 0;
        } else if (pref.type === SHIFT_TYPE_SUCCESSIONS) {
          return (pref as ShiftTypeSuccessionsPreference).person.length > 0 &&
            (pref as ShiftTypeSuccessionsPreference).pattern.length > 0;
        } else if (pref.type === SHIFT_COUNT) {
          return (pref as ShiftCountPreference).person.length > 0;
        }
        return true;
      })
    }));
  };

  const updateItem = (
    dataType: DataType,
    data: ItemGroupEditorPageData,
    oldId: string,
    newId: string,
    groupIds?: string[],
    description?: string
  ): void => {
    // Check if the new ID is a reserved keyword
    if (isReservedKeyword(dataType, newId)) {
      console.error(`Cannot update item to ID "${newId}" - it is a reserved keyword. ${ERROR_SHOULD_NOT_HAPPEN}`);
      return;
    }

    // First update the item's ID and description
    const updatedItems = data.items.map(item =>
      item.id === oldId
        ? { ...item, id: newId, description: description !== undefined ? description : item.description }
        : item
    );

    // Always update group memberships to reflect the new ID
    const updatedGroups = data.groups.map(group => {
      // Get current members excluding the edited item
      const otherMembers = group.members.filter(id => id !== oldId);

      // Add the item if they should be in this group
      const allMembers = groupIds
        ? (groupIds.includes(group.id) ? [...otherMembers, newId] : otherMembers)
        : (group.members.includes(oldId) ? [...otherMembers, newId] : otherMembers);

      // Sort members based on updated items order
      const sortedMembers = updatedItems
        .filter(item => allMembers.includes(item.id))
        .map(item => item.id);

      if (allMembers.length !== sortedMembers.length) {
        console.error(`All members length ${allMembers.length} does not match sorted members length ${sortedMembers.length}. ${ERROR_SHOULD_NOT_HAPPEN}`);
        return group;
      }

      return {
        ...group,
        members: sortedMembers
      };
    });

    const newData = { items: updatedItems, groups: updatedGroups };

    updateData(dataType, newData);
    updatePeopleHistoryForIdChange(dataType, oldId, newId);
    updatePreferencesForIdChange(dataType, oldId, newId);
  };

  const updateGroup = (
    dataType: DataType,
    data: ItemGroupEditorPageData,
    oldId: string,
    newId: string,
    members?: string[],
    description?: string
  ): void => {
    // Check if the new ID is a reserved keyword
    if (isReservedKeyword(dataType, newId)) {
      console.error(`Cannot update group to ID "${newId}" - it is a reserved keyword. ${ERROR_SHOULD_NOT_HAPPEN}`);
      return;
    }

    const group = data.groups.find(g => g.id === oldId);
    if (!group) {
      console.error(`Group with ID ${oldId} not found. ${ERROR_SHOULD_NOT_HAPPEN}`);
      return;
    }

    // Sort members based on items order
    const sortedMembers = members
      ? data.items
          .filter(item => members.includes(item.id))
          .map(item => item.id)
      : group.members;

    if (members && members.length !== sortedMembers.length) {
      console.error(`Members length ${members.length} does not match sorted members length ${sortedMembers.length}. ${ERROR_SHOULD_NOT_HAPPEN}`);
      return;
    }

    const newGroups = data.groups.map(g =>
      g.id === oldId
        ? { ...g, id: newId, members: sortedMembers, description: description !== undefined ? description : g.description }
        : g
    );

    const newData = { ...data, groups: newGroups };

    updateData(dataType, newData);
    updatePreferencesForIdChange(dataType, oldId, newId);
  };

  const deleteItem = (
    dataType: DataType,
    data: ItemGroupEditorPageData,
    id: string
  ): void => {
    if (isReservedKeyword(dataType, id)) {
      console.error(`Cannot delete item with ID "${id}" - it is a reserved keyword. ${ERROR_SHOULD_NOT_HAPPEN}`);
      return;
    }

    const newItems = data.items.filter(item => item.id !== id);
    const newGroups = data.groups.map(group => ({
      ...group,
      members: group.members.filter(memberId => memberId !== id)
    }));

    const newData = { items: newItems, groups: newGroups };

    updateData(dataType, newData);
    updatePreferencesForIdDeletion(dataType, id);
  };

  const deleteGroup = (
    dataType: DataType,
    data: ItemGroupEditorPageData,
    id: string
  ): void => {
    if (isReservedKeyword(dataType, id)) {
      console.error(`Cannot delete group with ID "${id}" - it is a reserved keyword. ${ERROR_SHOULD_NOT_HAPPEN}`);
      return;
    }

    const newGroups = data.groups.filter(g => g.id !== id);
    const newData = { ...data, groups: newGroups };

    updateData(dataType, newData);
    updatePreferencesForIdDeletion(dataType, id);
  };

  const removeItemFromGroup = (
    dataType: DataType,
    data: ItemGroupEditorPageData,
    itemId: string,
    groupId: string
  ): void => {
    if (isReservedKeyword(dataType, groupId)) {
      console.error(`Cannot remove item from group with ID "${groupId}" - it is a reserved keyword. ${ERROR_SHOULD_NOT_HAPPEN}`);
      return;
    }

    const newGroups = data.groups.map(group =>
      group.id === groupId
        ? { ...group, members: group.members.filter(id => id !== itemId) }
        : group
    );

    const newData = { ...data, groups: newGroups };

    updateData(dataType, newData);
  };

  const reorderItems = (
    dataType: DataType,
    data: ItemGroupEditorPageData,
    reorderedItems: Item[]
  ): void => {
    // Sort group members based on items order
    const updatedGroups = data.groups.map(group => ({
      ...group,
      members: reorderedItems
        .filter(item => group.members.includes(item.id))
        .map(item => item.id)
    }));

    const newData = { items: reorderedItems, groups: updatedGroups };

    updateData(dataType, newData);
  };

  const reorderGroups = (
    dataType: DataType,
    data: ItemGroupEditorPageData,
    newGroups: Group[]
  ): void => {
    const newData = { ...data, groups: newGroups };

    updateData(dataType, newData);
  };

  const addPersonHistory = (personId: string, shiftTypeId: string) => {
    updateState(prevState => {
      const updatedPeople = {
        ...prevState.people,
        items: prevState.people.items.map(person => {
          if (person.id === personId) {
            const newHistory = [shiftTypeId, ...person.history!];
            return { ...person, history: newHistory };
          }
          return person;
        })
      };
      return { ...prevState, people: updatedPeople };
    });
  };

  const updatePersonHistory = (personId: string, position: number, shiftTypeId?: string) => {
    updateState(prevState => {
      const updatedPeople = {
        ...prevState.people,
        items: prevState.people.items.map(person => {
          if (person.id === personId) {
            if (shiftTypeId !== undefined) {
              // Update the specific position
              const newHistory = [...person.history!];
              if (position >= newHistory.length) {
                console.error(`Position ${position} is out of bounds for person ${personId}. ${ERROR_SHOULD_NOT_HAPPEN}`);
                return person;
              }
              newHistory[position] = shiftTypeId;
              return { ...person, history: newHistory };
            } else {
              // Clear all history entries before the specified position
              const newHistory = person.history!.slice(position + 1);
              return { ...person, history: newHistory };
            }
          }
          return person;
        })
      };
      return { ...prevState, people: updatedPeople };
    });
  };

  // Helper functions to work with flattened preferences
  const getPreferencesByType = <T extends Preference>(type: string): T[] => {
    return historyState.state.preferences.filter(pref => pref.type === type) as T[];
  };

  const updatePreferences = (newPreferences: Preference[]) => {
    updateState(prevState => ({
      ...prevState,
      preferences: newPreferences
    }));
  };

  const updatePreferencesByType = <T extends Preference>(type: string, newPreferences: T[]) => {
    const otherPreferences = historyState.state.preferences.filter(pref => pref.type !== type);
    if (type === SHIFT_REQUEST) {
      const combinedPeopleEntries = [...historyState.state.people.groups, ...historyState.state.people.items];
      const combinedShiftTypeEntries = [...historyState.state.shiftTypes.groups, ...historyState.state.shiftTypes.items];
      const combinedDateEntries = [...historyState.state.dates.groups, ...historyState.state.dates.items];
      // Sort preferences by person, shift type, weight.
      (newPreferences as ShiftRequestPreference[]).sort((a, b) => {
        // Sort based on peopleData person index
        const peopleIndexA = combinedPeopleEntries.findIndex(p => p.id === a.person[0]);
        const peopleIndexB = combinedPeopleEntries.findIndex(p => p.id === b.person[0]);
        const personOrder = peopleIndexA - peopleIndexB;
        if (personOrder !== 0) return personOrder;
        // Sort based on shiftTypeData shift type index
        const shiftTypeIndexA = combinedShiftTypeEntries.findIndex(p => p.id === a.shiftType[0]);
        const shiftTypeIndexB = combinedShiftTypeEntries.findIndex(p => p.id === b.shiftType[0]);
        const shiftTypeOrder = shiftTypeIndexA - shiftTypeIndexB;
        if (shiftTypeOrder !== 0) return shiftTypeOrder;
        // Sort based on weight
        return a.weight - b.weight;
      });
      // Sort each preference date array
      (newPreferences as ShiftRequestPreference[]).forEach(pref => {
        if (pref.person.length !== 1) {
          console.error(`A single shift request corresponds to multiple people. ${ERROR_SHOULD_NOT_HAPPEN}`);
          return pref;
        }
        if (pref.shiftType.length !== 1) {
          console.error(`A single shift request corresponds to multiple shift types. ${ERROR_SHOULD_NOT_HAPPEN}`);
          return pref;
        }
        if (pref.date.length === 0) {
          console.error(`A single shift request corresponds to no dates. ${ERROR_SHOULD_NOT_HAPPEN}`);
          return pref;
        }
        pref.date.sort((a, b) => {
          const dateIndexA = combinedDateEntries.findIndex(p => p.id === a);
          const dateIndexB = combinedDateEntries.findIndex(p => p.id === b);
          return dateIndexA - dateIndexB;
        });
      });
    }
    // Sort preferences by type after updating
    const updatedPreferences = [...otherPreferences, ...newPreferences].sort((a, b) => {
      const typeOrder = [AT_MOST_ONE_SHIFT_PER_DAY, SHIFT_TYPE_REQUIREMENT, SHIFT_REQUEST, SHIFT_TYPE_SUCCESSIONS, SHIFT_COUNT];
      return typeOrder.indexOf(a.type) - typeOrder.indexOf(b.type);
    });
    updatePreferences(updatedPreferences);
  };

  const loadFromYaml = (yamlData: unknown) => {
    // Create new state from YAML data without validation
    // TODO: Add validation

    const newState: SchedulingState = addAutoGeneratedToState({
      apiVersion: yamlData.apiVersion || API_VERSION,
      description: yamlData.description || '',
      dates: {
        range: yamlData.dates?.range ? {
          startDate: yamlData.dates.range.startDate ? new Date(yamlData.dates.range.startDate) : undefined,
          endDate: yamlData.dates.range.endDate ? new Date(yamlData.dates.range.endDate) : undefined,
        } : { startDate: undefined, endDate: undefined },
        items: yamlData.dates?.items || [],
        groups: yamlData.dates?.groups || []
      },
      people: yamlData.people || { items: [], groups: [] },
      shiftTypes: yamlData.shiftTypes || { items: [], groups: [] },
      preferences: yamlData.preferences || []
    });

    // If any ID is a number, convert it to a string
    const convertIdsToString = (arr: { id: number | string }[]) => {
      arr.forEach(obj => {
        if (typeof obj.id === 'number') obj.id = String(obj.id);
      });
    };
    convertIdsToString(newState.dates.items);
    convertIdsToString(newState.dates.groups);
    convertIdsToString(newState.people.items);
    convertIdsToString(newState.people.groups);
    convertIdsToString(newState.shiftTypes.items);
    convertIdsToString(newState.shiftTypes.groups);
    const convertArrayIdsToString = (arr: (number | string)[], isDate: boolean = false) => {
      if (!Array.isArray(arr)) return;
      for (let i = 0; i < arr.length; i++) {
        if (typeof arr[i] === 'number') {
          if (isDate) {
            arr[i] = arr[i].toString().padStart(2, '0');
          } else {
            arr[i] = arr[i].toString();
          }
        }
      }
    };
    newState.preferences.forEach(pref => {
      convertArrayIdsToString(pref.shiftType);
      convertArrayIdsToString(pref.qualifiedPeople);
      convertArrayIdsToString(pref.date, true);
      convertArrayIdsToString(pref.person);
      convertArrayIdsToString(pref.shiftType);
      convertArrayIdsToString(pref.pattern);
      convertArrayIdsToString(pref.countDates, true);
      convertArrayIdsToString(pref.countShiftTypes);
    });

    // Add to history and update state
    setHistoryState(prevHistoryState => {
      const newHistoryState = addToHistory(prevHistoryState, newState);
      saveStateToStorage(newHistoryState);
      return newHistoryState;
    });
  };

  return {
    updateDateRange,
    apiVersionData: historyState.state.apiVersion,
    descriptionData: historyState.state.description,
    dateData: historyState.state.dates,
    peopleData: historyState.state.people,
    shiftTypeData: historyState.state.shiftTypes,

    // Flattened preferences API
    preferences: historyState.state.preferences,
    updatePreferences,
    updatePreferencesByType,
    getPreferencesByType,

    addPersonHistory,
    updatePersonHistory,
    createNewState,
    loadFromYaml,
    filterAutoGeneratedState,
    undo,
    redo,
    // Helper functions
    addItem,
    addGroup,
    updateItem,
    updateGroup,
    deleteItem,
    deleteGroup,
    removeItemFromGroup,
    reorderItems,
    reorderGroups,
  };
}
