/*
 * This file is part of Nurse Scheduling Project, see <https://github.com/j3soon/nurse-scheduling>.
 *
 * Copyright (C) 2023-2026 Johnson Sun
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

import { DataType, AutoGeneratedItem, AutoGeneratedGroup, Item, Group, DateRange } from '@/types/scheduling';
import { dateStrToDate } from './dateParsing';

export const OFF = 'OFF';
export const ALL = 'ALL';
export const WEEKDAY = 'WEEKDAY';
export const WEEKEND = 'WEEKEND';
export const MONDAY = 'MONDAY';
export const TUESDAY = 'TUESDAY';
export const WEDNESDAY = 'WEDNESDAY';
export const THURSDAY = 'THURSDAY';
export const FRIDAY = 'FRIDAY';
export const SATURDAY = 'SATURDAY';
export const SUNDAY = 'SUNDAY';

export const API_VERSION = 'alpha';

export const AUTO_GENERATED_ITEMS: Record<DataType, AutoGeneratedItem[]> = {
  [DataType.PEOPLE]: [],
  [DataType.SHIFT_TYPES]: [
    {
      id: OFF,
      description: 'Off shift type'
    }
  ],
  [DataType.DATES]: []
};

export const AUTO_GENERATED_GROUPS: Record<DataType, AutoGeneratedGroup[]> = {
  [DataType.PEOPLE]: [
    {
      id: ALL,
      description: 'Group containing all people',
      generateMembers: (items: Item[]) => items.map(item => item.id)
    }
  ],
  [DataType.SHIFT_TYPES]: [
    {
      id: ALL,
      description: 'Group containing all shift types',
      generateMembers: (items: Item[]) => items.map(item => item.id)
    }
  ],
  [DataType.DATES]: [
    {
      id: ALL,
      description: 'Group containing all dates',
      generateMembers: (items: Item[]) => items.map(item => item.id)
    },
    {
      id: WEEKDAY,
      description: 'Group containing all weekdays',
      generateMembers: (items: Item[], dateRange?: DateRange) => {
        return dateRange && dateRange.startDate ? items.filter(item => {
            const dayOfWeek = dateStrToDate(item.id, dateRange!).getDay();
            // 0 = Sunday, 6 = Saturday
            return dayOfWeek >= 1 && dayOfWeek <= 5;
          }).map(item => item.id) : [];
      }
    },
    {
      id: WEEKEND,
      description: 'Group containing all weekends',
      generateMembers: (items: Item[], dateRange?: DateRange) => {
        return dateRange && dateRange.startDate ? items.filter(item => {
            const dayOfWeek = dateStrToDate(item.id, dateRange!).getDay();
            // 0 = Sunday, 6 = Saturday
            return dayOfWeek === 0 || dayOfWeek === 6;
          }).map(item => item.id) : [];
        }
    },
    {
      id: SUNDAY,
      description: 'Group containing all Sundays',
      generateMembers: (items: Item[], dateRange?: DateRange) => {
        return dateRange && dateRange.startDate ? items.filter(item => dateStrToDate(item.id, dateRange!).getDay() === 0).map(item => item.id) : [];
      }
    },
    {
      id: MONDAY,
      description: 'Group containing all Mondays',
      generateMembers: (items: Item[], dateRange?: DateRange) => {
        return dateRange && dateRange.startDate ? items.filter(item => dateStrToDate(item.id, dateRange!).getDay() === 1).map(item => item.id) : [];
      }
    },
    {
      id: TUESDAY,
      description: 'Group containing all Tuesdays',
      generateMembers: (items: Item[], dateRange?: DateRange) => {
        return dateRange && dateRange.startDate ? items.filter(item => dateStrToDate(item.id, dateRange!).getDay() === 2).map(item => item.id) : [];
      }
    },
    {
      id: WEDNESDAY,
      description: 'Group containing all Wednesdays',
      generateMembers: (items: Item[], dateRange?: DateRange) => {
        return dateRange && dateRange.startDate ? items.filter(item => dateStrToDate(item.id, dateRange!).getDay() === 3).map(item => item.id) : [];
      }
    },
    {
      id: THURSDAY,
      description: 'Group containing all Thursdays',
      generateMembers: (items: Item[], dateRange?: DateRange) => {
        return dateRange && dateRange.startDate ? items.filter(item => dateStrToDate(item.id, dateRange!).getDay() === 4).map(item => item.id) : [];
      }
    },
    {
      id: FRIDAY,
      description: 'Group containing all Fridays',
      generateMembers: (items: Item[], dateRange?: DateRange) => {
        return dateRange && dateRange.startDate ? items.filter(item => dateStrToDate(item.id, dateRange!).getDay() === 5).map(item => item.id) : [];
      }
    },
    {
      id: SATURDAY,
      description: 'Group containing all Saturdays',
      generateMembers: (items: Item[], dateRange?: DateRange) => {
        return dateRange && dateRange.startDate ? items.filter(item => dateStrToDate(item.id, dateRange!).getDay() === 6).map(item => item.id) : [];
      }
    }
  ]
};

export function getReservedKeywords(dataType: DataType): string[] {
  const itemKeywords = AUTO_GENERATED_ITEMS[dataType].map(item => item.id);
  const groupKeywords = AUTO_GENERATED_GROUPS[dataType].map(group => group.id);
  return [...itemKeywords, ...groupKeywords];
}

export function isReservedKeyword(dataType: DataType, id: string): boolean {
  return getReservedKeywords(dataType).some(keyword => keyword.toLowerCase() === id.toLowerCase());
}

export function filterAutoGenerated(items?: (Item | Group)[]): (Item | Group)[] {
  return items?.filter(item => !item.isAutoGenerated) ?? [];
}
