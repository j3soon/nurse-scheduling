/*
 * This file is part of Nurse Scheduling Project, see <https://github.com/j3soon/nurse-scheduling>.
 *
 * Copyright (C) 2023-2025 Johnson Sun
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

// A component for the columns of the table that displays the items and groups that can be edited inline.
'use client';

import { useRef, useState, useEffect, ReactNode } from 'react';
import { FiChevronDown } from 'react-icons/fi';
import { InlineEdit } from '@/components/InlineEdit';
import { RemovableTag } from '@/components/RemovableTag';
import { TableRowActions } from '@/components/TableRowActions';
import { Item, Group } from '@/types/scheduling';
import { Mode } from '@/constants/modes';
import { ERROR_SHOULD_NOT_HAPPEN } from '@/constants/errors';

// Component to display members/groups with count and overflow indicator
function MembersCell({ count, label, children }: { count: number; label: string; children: ReactNode }) {
  const containerRef = useRef<HTMLDivElement>(null);
  const [hasOverflow, setHasOverflow] = useState(false);

  useEffect(() => {
    const checkOverflow = () => {
      if (containerRef.current) {
        setHasOverflow(containerRef.current.scrollHeight > containerRef.current.clientHeight);
      }
    };
    checkOverflow();
    // Re-check on window resize
    window.addEventListener('resize', checkOverflow);
    return () => window.removeEventListener('resize', checkOverflow);
  }, [children]);

  return (
    <div>
      <div className="flex items-center gap-1 text-xs text-gray-500 mb-1">
        <span>{count} {label}</span>
        {hasOverflow && <FiChevronDown className="w-3 h-3" title="Scroll for more" />}
      </div>
      <div
        ref={containerRef}
        className="flex flex-wrap gap-1 max-h-28 overflow-y-auto"
      >
        {children}
      </div>
    </div>
  );
}

interface TableColumnsProps {
  mode: Mode;
  inlineEditingId: string;
  inlineEditingField: 'id' | 'description';
  error: string;
  showIndexPrefix: boolean;
  onInlineSave: (id: string, field: 'id' | 'description', isItem: boolean, value: string) => void;
  onInlineCancel: () => void;
  onInlineEdit: (id: string, isItem: boolean, field?: 'id' | 'description') => void;
  onEdit: (id: string) => void;
  onDelete: (id: string) => void;
  removeItemFromGroup: (itemId: string, groupId: string) => void;
  itemsReadOnly?: boolean;
}

interface BaseTableConfig {
  isItemTable: boolean;
  items?: Item[];
  groups?: Group[];
  secondColumnHeader: string;
  readOnly?: boolean;
}

// Common ID column component
function IdColumn({
  item,
  isItem,
  index,
  showIndexPrefix = true,
  mode,
  inlineEditingId,
  inlineEditingField,
  onInlineSave,
  onInlineCancel,
  onInlineEdit,
  error,
  itemsReadOnly = false,
}: {
  item: Item;
  isItem: boolean;
  index: number;
  showIndexPrefix: boolean;
  mode: Mode;
  inlineEditingId: string;
  inlineEditingField: 'id' | 'description';
  onInlineSave: (id: string, field: 'id' | 'description', isItem: boolean, value: string) => void;
  onInlineCancel: () => void;
  onInlineEdit: (id: string, isItem: boolean, field?: 'id' | 'description') => void;
  error: string;
  itemsReadOnly?: boolean;
}) {
  const canEdit = !(isItem && itemsReadOnly) && !item.isAutoGenerated;
  const displayValue = showIndexPrefix ? `${index + 1}. ${item.id}` : item.id;

  return (
    <div>
      <InlineEdit
        value={item.id}
        displayValue={displayValue}
        isEditing={mode === Mode.INLINE_EDITING && inlineEditingId === item.id && inlineEditingField === 'id'}
        onSave={(value) => onInlineSave(item.id, 'id', isItem, value)}
        onCancel={onInlineCancel}
        onDoubleClick={canEdit ? () => onInlineEdit(item.id, isItem, 'id') : undefined}
        error={error}
      />
      <InlineEdit
        value={item.description}
        isEditing={mode === Mode.INLINE_EDITING && inlineEditingId === item.id && inlineEditingField === 'description'}
        onSave={(value) => onInlineSave(item.id, 'description', isItem, value)}
        onCancel={onInlineCancel}
        onDoubleClick={canEdit ? () => onInlineEdit(item.id, isItem, 'description') : undefined}
        className="text-xs text-gray-400 mt-1 max-w-[150px] truncate block"
        editClassName="text-xs mt-1 w-full"
        emptyText="Add description..."
        placeholder="Enter description..."
      />
    </div>
  );
}

// Base table columns function
function useBaseTableColumns(
  props: TableColumnsProps,
  config: BaseTableConfig
) {
  const {
    mode,
    inlineEditingId,
    inlineEditingField,
    error,
    showIndexPrefix = true,
    onInlineSave,
    onInlineCancel,
    onInlineEdit,
    onEdit,
    onDelete,
    removeItemFromGroup,
  } = props;

  const {
    isItemTable,
    items = [],
    groups = [],
    secondColumnHeader,
    readOnly = false,
  } = config;

  const columns: Array<{
    header: string;
    accessor: (entity: Item | Group, index: number) => React.ReactElement;
    align?: 'left' | 'center' | 'right';
  }> = [
    {
      header: 'ID',
      accessor: (entity: Item | Group, index: number) => (
        <IdColumn
          item={entity}
          isItem={isItemTable}
          index={index}
          showIndexPrefix={showIndexPrefix}
          mode={mode}
          inlineEditingId={inlineEditingId}
          inlineEditingField={inlineEditingField}
          onInlineSave={onInlineSave}
          onInlineCancel={onInlineCancel}
          onInlineEdit={onInlineEdit}
          error={error}
          itemsReadOnly={readOnly}
        />
      )
    },
    {
      header: secondColumnHeader,
      accessor: (entity: Item | Group, _index: number) => {
        if (isItemTable) {
          // For items: show groups that contain this item
          const item = entity as Item;
          const matchingGroups = groups.filter(group => group.members.includes(item.id));
          return (
            <MembersCell count={matchingGroups.length} label={matchingGroups.length === 1 ? 'group' : 'groups'}>
              {matchingGroups.map(group => (
                <RemovableTag
                  key={group.id}
                  id={group.id}
                  description={group.description}
                  onRemove={() => removeItemFromGroup(item.id, group.id)}
                  variant="blue"
                  readOnly={item.isAutoGenerated || group.isAutoGenerated}
                />
              ))}
            </MembersCell>
          );
        } else {
          // For groups: show members of this group
          const group = entity as Group;
          return (
            <MembersCell count={group.members.length} label={group.members.length === 1 ? 'member' : 'members'}>
              {group.members
                .map(memberId => items.find(i => i.id === memberId))
                .map((item, index) => {
                  if (!item) {
                    const memberId = group.members[index];
                    console.error(`Group '${group.id}' referenced a non-existent ID: ${memberId}. ${ERROR_SHOULD_NOT_HAPPEN}`);
                    return null;
                  }
                  return (
                    <RemovableTag
                      key={item.id}
                      id={item.id}
                      description={item.description}
                      onRemove={() => removeItemFromGroup(item.id, group.id)}
                      variant="gray"
                      readOnly={item.isAutoGenerated || group.isAutoGenerated}
                    />
                  );
                })}
            </MembersCell>
          );
        }
      }
    }
  ];

  // Only add Actions column if not in read-only mode
  if (!readOnly) {
    columns.push({
      header: 'Actions',
      accessor: (entity: Item | Group, _index: number) => {
        // Don't show actions for auto-generated groups
        if (entity.isAutoGenerated) {
          return <div className="text-sm text-blue-600 italic">Auto</div>;
        }
        return (
          <TableRowActions
            onEdit={() => onEdit(entity.id)}
            onDelete={() => onDelete(entity.id)}
          />
        );
      },
      align: 'center' as const,
    });
  }

  return columns;
}

export function useItemTableColumns({
  groups,
  itemsReadOnly = false,
  ...props
}: TableColumnsProps & { groups: Group[]; }) {
  return useBaseTableColumns(props, {
    isItemTable: true,
    groups,
    secondColumnHeader: "Groups",
    readOnly: itemsReadOnly,
  });
}

export function useGroupTableColumns({
  items,
  groupsReadOnly = false,
  ...props
}: TableColumnsProps & { items: Item[]; groupsReadOnly?: boolean }) {
  return useBaseTableColumns(props, {
    isItemTable: false,
    items,
    secondColumnHeader: 'Members',
    readOnly: groupsReadOnly,
  });
}
