// A component for the columns of the table that displays the items and groups that can be edited inline.
'use client';

import { InlineEdit } from '@/components/InlineEdit';
import { RemovableTag } from '@/components/RemovableTag';
import { TableRowActions } from '@/components/TableRowActions';
import { Item, Group } from '@/types/scheduling';
import { Mode } from '@/constants/modes';
import { ERROR_SHOULD_NOT_HAPPEN } from '@/constants/errors';

interface TableColumnsProps {
  mode: Mode;
  inlineEditingId: string;
  inlineEditingField: 'id' | 'description';
  error: string;
  onInlineSave: (id: string, field: 'id' | 'description', isItem: boolean, value: string) => void;
  onInlineCancel: () => void;
  onInlineEdit: (id: string, isItem: boolean, field?: 'id' | 'description') => void;
  onEdit: (id: string) => void;
  onDelete: (id: string) => void;
  removeItemFromGroup: (itemId: string, groupId: string) => void;
  itemsReadOnly?: boolean;
}

interface BaseTableConfig {
  isItemTable: boolean;
  items?: Item[];
  groups?: Group[];
  secondColumnHeader: string;
  readOnly?: boolean;
}

// Common ID column component
function IdColumn({
  item,
  isItem,
  index,
  mode,
  inlineEditingId,
  inlineEditingField,
  onInlineSave,
  onInlineCancel,
  onInlineEdit,
  error,
  itemsReadOnly = false,
}: {
  item: Item;
  isItem: boolean;
  index: number;
  mode: Mode;
  inlineEditingId: string;
  inlineEditingField: 'id' | 'description';
  onInlineSave: (id: string, field: 'id' | 'description', isItem: boolean, value: string) => void;
  onInlineCancel: () => void;
  onInlineEdit: (id: string, isItem: boolean, field?: 'id' | 'description') => void;
  error: string;
  itemsReadOnly?: boolean;
}) {
  const canEdit = !(isItem && itemsReadOnly) && !item.isAutoGenerated;

  return (
    <div>
      <InlineEdit
        value={item.id}
        displayValue={isItem ? `${index + 1}. ${item.id}` : item.id}
        isEditing={mode === Mode.INLINE_EDITING && inlineEditingId === item.id && inlineEditingField === 'id'}
        onSave={(value) => onInlineSave(item.id, 'id', isItem, value)}
        onCancel={onInlineCancel}
        onDoubleClick={canEdit ? () => onInlineEdit(item.id, isItem, 'id') : undefined}
        error={error}
      />
      <InlineEdit
        value={item.description}
        isEditing={mode === Mode.INLINE_EDITING && inlineEditingId === item.id && inlineEditingField === 'description'}
        onSave={(value) => onInlineSave(item.id, 'description', isItem, value)}
        onCancel={onInlineCancel}
        onDoubleClick={canEdit ? () => onInlineEdit(item.id, isItem, 'description') : undefined}
        className="text-xs text-gray-400 mt-1"
        editClassName="text-xs mt-1 w-full"
        emptyText="Add description..."
        placeholder="Enter description..."
      />
    </div>
  );
}

// Base table columns function
function useBaseTableColumns(
  props: TableColumnsProps,
  config: BaseTableConfig
) {
  const {
    mode,
    inlineEditingId,
    inlineEditingField,
    error,
    onInlineSave,
    onInlineCancel,
    onInlineEdit,
    onEdit,
    onDelete,
    removeItemFromGroup,
  } = props;

  const {
    isItemTable,
    items = [],
    groups = [],
    secondColumnHeader,
    readOnly = false,
  } = config;

  const columns: Array<{
    header: string;
    accessor: (entity: Item | Group, index: number) => React.ReactElement;
    align?: 'left' | 'center' | 'right';
  }> = [
    {
      header: 'ID',
      accessor: (entity: Item | Group, index: number) => (
        <IdColumn
          item={entity}
          isItem={isItemTable}
          index={index}
          mode={mode}
          inlineEditingId={inlineEditingId}
          inlineEditingField={inlineEditingField}
          onInlineSave={onInlineSave}
          onInlineCancel={onInlineCancel}
          onInlineEdit={onInlineEdit}
          error={error}
          itemsReadOnly={readOnly}
        />
      )
    },
    {
      header: secondColumnHeader,
      accessor: (entity: Item | Group, _index: number) => {
        if (isItemTable) {
          // For items: show groups that contain this item
          const item = entity as Item;
          return (
            <div className="flex flex-wrap gap-1">
              {groups
                .filter(group => group.members.includes(item.id))
                .map(group => (
                  <RemovableTag
                    key={group.id}
                    id={group.id}
                    description={group.description}
                    onRemove={() => removeItemFromGroup(item.id, group.id)}
                    variant="blue"
                    readOnly={item.isAutoGenerated || group.isAutoGenerated}
                  />
                ))}
            </div>
          );
        } else {
          // For groups: show members of this group
          const group = entity as Group;
          return (
            <div className="flex flex-wrap gap-1">
              {group.members
                .map(memberId => items.find(i => i.id === memberId))
                .map((item, index) => {
                  if (!item) {
                    const memberId = group.members[index];
                    console.error(`Group '${group.id}' referenced a non-existent ID: ${memberId}. ${ERROR_SHOULD_NOT_HAPPEN}`);
                    return null;
                  }
                  return (
                    <RemovableTag
                      key={item.id}
                      id={item.id}
                      description={item.description}
                      onRemove={() => removeItemFromGroup(item.id, group.id)}
                      variant="gray"
                      readOnly={item.isAutoGenerated || group.isAutoGenerated}
                    />
                  );
                })}
            </div>
          );
        }
      }
    }
  ];

  // Only add Actions column if not in read-only mode
  if (!readOnly) {
    columns.push({
      header: 'Actions',
      accessor: (entity: Item | Group, _index: number) => {
        // Don't show actions for auto-generated groups
        if (entity.isAutoGenerated) {
          return <div className="text-sm text-blue-600 italic">Auto-generated</div>;
        }
        return (
          <TableRowActions
            onEdit={() => onEdit(entity.id)}
            onDelete={() => onDelete(entity.id)}
          />
        );
      },
      align: 'right' as const
    });
  }

  return columns;
}

export function useItemTableColumns({
  groups,
  itemsReadOnly = false,
  ...props
}: TableColumnsProps & { groups: Group[]; }) {
  return useBaseTableColumns(props, {
    isItemTable: true,
    groups,
    secondColumnHeader: "Groups",
    readOnly: itemsReadOnly,
  });
}

export function useGroupTableColumns({
  items,
  groupsReadOnly = false,
  ...props
}: TableColumnsProps & { items: Item[]; groupsReadOnly?: boolean }) {
  return useBaseTableColumns(props, {
    isItemTable: false,
    items,
    secondColumnHeader: 'Members',
    readOnly: groupsReadOnly,
  });
}
